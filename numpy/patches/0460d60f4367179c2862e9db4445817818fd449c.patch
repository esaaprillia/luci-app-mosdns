From 0460d60f4367179c2862e9db4445817818fd449c Mon Sep 17 00:00:00 2001
From: esaaprillia <esaapriliasalsabila@gmail.com>
Date: Tue, 29 Oct 2024 08:39:38 +0800
Subject: [PATCH] Add files via upload

---
 numpy/_core/meson.build | 90 -----------------------------------------
 1 file changed, 90 deletions(-)

diff --git a/numpy/_core/meson.build b/numpy/_core/meson.build
index dbf1a14..30bacdb 100644
--- a/numpy/_core/meson.build
+++ b/numpy/_core/meson.build
@@ -398,96 +398,6 @@ foreach intrin: optional_intrinsics
   endif
 endforeach
 
-# This is a port of the old python code for identifying the long double
-# representation to C.  The old Python code is in this range:
-# https://github.com/numpy/numpy/blob/eead09a3d02c09374942cdc787c0b5e4fe9e7472/numpy/core/setup_common.py#L264-L434
-# This port is in service of solving gh-23972
-# as well as https://github.com/mesonbuild/meson/issues/11068
-longdouble_format = meson.get_external_property('longdouble_format', 'UNKNOWN')
-if longdouble_format == 'UNKNOWN'
-  longdouble_format = meson.get_compiler('c').run(
-'''
-#include <stdio.h>
-#include <string.h>
-
-#define repcmp(z) (memcmp((const char *)&foo.x, z, sizeof(foo.x)) == 0)
-
-const struct {
-  char before[16];
-  long double x;
-  char after[8];
-} foo = {{'\0'}, -123456789.0, {'\0'}};
-
-int main(void) {
-  switch (sizeof(foo.x)) {
-  case 8: {
-    if (repcmp(
-            ((const char[]){0000, 0000, 0000, 0124, 0064, 0157, 0235, 0301}))) {
-      fprintf(stdout, "IEEE_DOUBLE_LE");
-      return 0;
-    }
-    if (repcmp(
-            ((const char[]){0301, 0235, 0157, 0064, 0124, 0000, 0000, 0000}))) {
-      fprintf(stdout, "IEEE_DOUBLE_BE");
-      return 0;
-    }
-    fprintf(stdout, "UNKNOWN");
-    return 1;
-  }
-  case 12: {
-    if (repcmp(((const char[]){0000, 0000, 0000, 0000, 0240, 0242, 0171, 0353,
-                               0031, 0300, 0000, 0000}))) {
-      fprintf(stdout, "INTEL_EXTENDED_12_BYTES_LE");
-      return 0;
-    }
-    if (repcmp(((const char[]){0300, 0031, 0000, 0000, 0353, 0171, 0242, 0240,
-                               0000, 0000, 0000, 0000}))) {
-      fprintf(stdout, "MOTOROLA_EXTENDED_12_BYTES_BE");
-      return 0;
-    }
-    fprintf(stdout, "UNKNOWN");
-    return 1;
-  }
-  case 16: {
-    if (repcmp(
-            ((const char[]){0000, 0000, 0000, 0000, 0240, 0242, 0171, 0353,
-                            0031, 0300, 0000, 0000, 0000, 0000, 0000, 0000}))) {
-      fprintf(stdout, "INTEL_EXTENDED_16_BYTES_LE");
-      return 0;
-    }
-    if (repcmp(
-            ((const char[]){0300, 0031, 0326, 0363, 0105, 0100, 0000, 0000,
-                            0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000}))) {
-      fprintf(stdout, "IEEE_QUAD_BE");
-      return 0;
-    }
-    if (repcmp(
-            ((const char[]){0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000,
-                            0000, 0000, 0100, 0105, 0363, 0326, 0031, 0300}))) {
-      fprintf(stdout, "IEEE_QUAD_LE");
-      return 0;
-    }
-    if (repcmp(
-            ((const char[]){0000, 0000, 0000, 0124, 0064, 0157, 0235, 0301,
-                            0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000}))) {
-      fprintf(stdout, "IBM_DOUBLE_DOUBLE_LE");
-      return 0;
-    }
-    if (repcmp(
-            ((const char[]){0301, 0235, 0157, 0064, 0124, 0000, 0000, 0000,
-                            0000, 0000, 0000, 0000, 0000, 0000, 0000, 0000}))) {
-      fprintf(stdout, "IBM_DOUBLE_DOUBLE_BE");
-      return 0;
-    }
-    fprintf(stdout, "UNKNOWN");
-    return 1;
-  }
-  }
-}
-  ''').stdout()
-endif
-if longdouble_format == 'UNKNOWN' or longdouble_format == 'UNDEFINED'
-  error('Unknown long double format of size: ' + cc.sizeof('long double').to_string())
 endif
 cdata.set10('HAVE_LDOUBLE_' + longdouble_format, true)
 
